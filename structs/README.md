# struct

## Отличие от `class`
- `class` - reference type, `struct` - value type
  - Передача `class` как аргумента = передача ссылки; передача `struct` - создание копии участка памяти ([демо](./code/Examples/ReferenceVsValueType.cs)) 
    - Не всегда - см. [модификаторы](#Модификаторы)
- Приведение структуры к reference type (типу object или одному из реализуемых интерфейсов) приводит к упаковке (boxing) - копированию и размещению структуры в heap
- Ограничения
  - До C# 10 нельзя переопределить безпараметрический конструктор и значения свойств/полей по умолчанию
  - Конструктор должен инициализировать все члены структуры
  - Наследовать тип - нельзя, наследоваться от структуры - тоже
  - Структура может реализовывать интерфейсы
    - Приведение структуры к интерфейсу или `object` приводит к упаковке (boxing)
- defensive copy (защитная копия)
  - При обращении к свойствам и методам non-readonly структуры, хранимой в readonly-поле или переданной в метод как in, создается её копия ([демо](./code/Examples/DefensiveCopy.cs))
  - Предотвращает модификацию структуры

## Модификаторы
### Модификаторы типа
- `readonly` - make structs immutable ~~again~~. В некоторых случаях предотвращает создание defensive copy
  - В `readonly struct` все поля должны быть `readonly`, а свойства не могут иметь `set` accessors
- `ref` - говорит компилятору, что структура может быть размещена только на стеке, но не в heap
  - Нельзя упаковывать (boxing)
  - Может быть членом только другой `ref struct`, но не обычной структуры или класса
  - Не может использоваться в async-методах, в итераторах, лямбдах или локальных методах (под капотом генерируется класс - см. предыдущий пункт)
### Модификаторы параметра метода
- `ref` - передается ссылка на структуру, копирование не происходит. Значение структуры вне метода может быть изменено внутри метода
  - Поддерживается и для возвращаемого значения/локальных переменных. Работает так же.
- `in` - под капотом тот же `ref`, но запрещает изменение
  - Так же применим к возвращаемому значению и локальным переменным, но имеет другой синтаксис - `readonly ref`

## Влияние на производительность
- Для `struct` не нужно аллоцировать место в heap'e, GC не нужно отслеживать ссылки, не нужно делать дефрагментацию памяти
  - Исключение - упаковка (boxing)
- Много операций копирования структуры - потенциальный bottleneck, если вызывается многократно (сотни тысяч раз)
  - В том числе относится и к defensive copy
- В массивах хранятся значения, а не ссылки
  - Процессорные промахи в кэш случаются реже (при копировании из RAM в CPU cache копируются целые страницы)

## Когда и как следует использовать
### Общие рекомендации
Важно понимать что универсального правила нет. Есть общие рекомендации, которые помогут сохранить производительность и избежать большинства багов. Отклонение требует понимания работы struct'ов и должно быть осознанным
- Все структуры рекомендуется делать `readonly` - меньше багов, меньше копирований
- Рекомендуется в методах, принимающих структуру, помечать соответствующий параметр как `in`
- Свойства желательно заменить на поля - так же помогает избежать не нужных операций копирования
- Желательно чтобы структура имела малый размер (<16 байт)
  - Больше - допустимо, но нужно убедиться, что структура не будет копироваться слишком часто

### Common use cases
- Набор параметров метода, сгруппированных в тип, или же возвращаемое методом значение ([пример](./code/Examples/CommonCases/FindEntityArgs.cs))
- Типы, которые очень похожи на примитивы (например, `DateTime`, `Span<>` или [`ByteSize`](https://github.com/omar/ByteSize))
- Конфигурация, предполагающая Fluent API (разного рода Builder'ы) ([пример](./code/Examples/CommonCases/FluentHttpRequest.cs))
- Обёртка над примитивами чтобы добавить ясности и избежать ошибок ([пример](./code/Examples/CommonCases/ApiUri.cs))

### С осторожностью
- mutable структуры могут стать источником неочевидных багов. Например:	
    ```c#
    class ReadOnlyEnumerator
    {
        private readonly List<int>.Enumerator _enumerator;
	
        public ReadOnlyEnumerator(List<int> list) =>
            _enumerator = list.GetEnumerator();

        public int GetFirstElement()
        {
            _enumerator.MoveNext();
            return _enumerator.Current;
        }
    }
    ```
    Вызов `new ReadOnlyEnumerator(new List<int>{1,2}).GetFirstElement();` вернёт 0, т.к. `List<>.Enumerator` является mutable структурой. 
    В классе она помещена в readonly-поле, а значит при обращении создается defensive copy, и `MoveNext()` вызывается по сути для другого экземпляра

## C# 10 Features
- Добавлена возможность переопределить безпараметрический конструктор и значения свойств/полей по умолчанию
- Добавлена поддержка оператора `with` для структур
- [`records`](../records) могут быть `struct`

## Материалы и источники

- [Краткий ликбез о производительности \[RU\]](https://habr.com/ru/company/microsoft/blog/423053/)
- [Коротко о модификаторах структук \[RU\]](https://andrey.moveax.ru/post/csharp-features-v7-2#newsemantic)
- [Когда использовать struct - MSDN \[EN\]](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)
- [Защитные копии - MS devblogs \[EN\]](https://devblogs.microsoft.com/premier-developer/the-in-modifier-and-the-readonly-structs-in-c/)
- [Падения производительности - MS devblogs \[EN\]](https://devblogs.microsoft.com/premier-developer/performance-traps-of-ref-locals-and-ref-returns-in-c/)
- Подробнее о реализации структур в CLR \[RU\\EN\] - Jeffrey Richter - CLR via C# - ch. 5 Primitive, Reference, and Value Types - Reference Types and Value Types
- [ErrorProne.NET - Набор Roslyn анализаторов, включающих анализ использования struct'ов](https://github.com/SergeyTeplyakov/ErrorProne.NET#struct-analyzers)
