## struct

### Отличие от `class`
- `class` - reference type, `struct` - value type
	- Передача `class` как аргумента = передача ссылки; передача `struct` - создание копии участка памяти 
		- Не всегда - см. [модификаторы](#Модификаторы)
- Приведение структуры к reference type (типу object или одному из реализуемых интерфейсов) приводит к упаковке (boxing) - копированию и размещению структуры в heap
- Ограничения
	- До C# 10 нельзя переопределить безпараметрический конструктор и значения свойств/полей по умолчанию
	- Конструктор должен инициализировать все члены структуры
	- Наследовать тип - нельзя, наследоваться от структуры - тоже
	- Структура может реализовывать интерфейсы
		- Приведение структуры к интерфейсу приводит к упаковке (boxing)
- defensive copy (защитная копия)
	- При обращении к свойствам и методам non-readonly структуры, хранимой в readonly-поле или переданной в метод как in, создается её копия
	- Предотвращает модификацию структуры

### C# 10 Features
- До C# 10 нельзя было переопределить безпараметрический конструктор и значения свойств/полей по умолчанию
- Начиная с C# 10 добавлена поддержка оператора `with` для структур

### Модификаторы
- Модификаторы типа
	- `readonly` - make structs immutable ~~again~~. В некоторых случаях предотвращает создание defensive copy
	- `ref` - говорит компилятору, что структура может быть размещена только на стеке, но не в heap
		- Нельзя упаковывать (boxing)
		- Может быть членом только другой `ref struct`, но не обычной структуры или класса
		- Не может использоваться в async-методах, в итераторах, лямбдах или локальных методах (под капотом генерируется класс - см. предыдущий пункт)
- Модификаторы параметра метода
	- `ref` - передается ссылка на структуру, копирование не происходит. Значение структуры вне метода может быть изменено внутри метода
	- `in` - под капотом тот же `ref`, но запрещает изменение

### Влияние на производительность
- Для `struct` не нужно аллоцировать место в heap'e, GC не нужно отслеживать ссылки, не нужно делать дефрагментацию памяти
	- Исключение - упаковка (boxing)
- Много операций копирования структуры - потенциальный bottleneck, если вызывается многократно (сотни тысяч раз)
	- В том числе относится и к defensive copy
- В массивах хранятся значения, а не ссылки
	- Процессорные промахи в кэш случаются реже (при копировании из RAM в CPU cache копируются целые страницы)

### Когда и как следует использовать
- Универсального правила - нет, но есть общие рекомендации. Отклонение требует понимания работы struct'ов и должно быть осознанным
	- Все структуры рекомендуется делать `readonly` - меньше багов, меньше копирований
	- Рекомендуется в методах, принимающих структуру, помечать соответствующий параметр как `in`
	- Свойства желательно заменить на поля - так же помогает избежать не нужных операций копирования
	- Желательно чтобы структура имела малый размер (<16 байт)
		- Больше - допустимо, но нужно убедиться, что структура не будет копироваться слишком часто

- Скорее всего, структура подойдет в следующих случаях:
	- Набор параметров метода, сгруппированных в тип, или же возвращаемое методом значение
	- Типы, которые очень похожи на примитивы (например, `DateTime`, `TimeSpan` или [`ByteSize`](https://github.com/omar/ByteSize))
	- Конфигурация, предполагающая Fluent API (разного рода Builder'ы)
	- Обёртка над примитивами чтобы добавить ясности и избежать ошибок
		- Например, если в клиентской библиотеке в качестве аргумента конструктора нужно передать базовый адрес API:
		```c#
			public readonly struct ApiUri
			{
				public readonly string Address;

				public ApiUri(string address) => this.Address = address;

				public static WebAppDomain Local => new WebAppDomain("https://localhost:5001/");
			}
		```

- С осторожностью
	- mutable структуры могут стать источником неочевидных багов. Например:
		```c#
		class ReadOnlyEnumerator
		{
			private readonly List<int>.Enumerator _enumerator;
		
			public ReadOnlyEnumerator(List<int> list) =>
				_enumerator = list.GetEnumerator();

			public int GetFirstElement()
			{
				_enumerator.MoveNext();
				return _enumerator.Current;
			}
		
		}
		```
    Вызов `new ReadOnlyEnumerator(new List<int>{1,2}).GetFirstElement();` вернёт 0, т.к. `List<>.Enumerator` является mutable структурой. 
		В классе она помещена в readonly-поле, а значит при обращении создается defensive copy, и `MoveNext()` вызывается по сути для другого экземпляра

- [ErrorProne.NET](https://github.com/SergeyTeplyakov/ErrorProne.NET#struct-analyzers)
	- Набор Roslyn анализаторов кода, включающих в том числе анализ использования struct'ов
